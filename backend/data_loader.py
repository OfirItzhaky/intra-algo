# -*- coding: utf-8 -*-
"""data_loader

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UFhcf82boO7DCzASVwBO77tB0I7JZ0zB
"""

import yfinance as yf
import pandas as pd
import numpy as np
class DataLoader:
    """
    A class responsible for loading market data either from a CSV file or from Yahoo Finance API.

    Methods
    -------
    load_from_csv(file_path: str) -> pd.DataFrame:
        Loads market data from a CSV file.

    fetch_market_data_from_yahoo(symbol: str, interval: str, start_date: str, end_date: str) -> pd.DataFrame:
        Fetches market data from Yahoo Finance API for a given symbol and time range.
    """

    def __init__(self):
        """
        Initializes the DataLoader class, no parameters required.
        """
        pass

    def load_from_csv(self, file_path: str) -> pd.DataFrame:
        """
        @param file_path: Path to the CSV file containing the market data.
        @return: A pandas DataFrame containing the market data, or an empty DataFrame if an error occurs.
        """
        try:
            data = pd.read_csv(file_path)
            print(f"Data successfully loaded from {file_path}")
            return data
        except FileNotFoundError:
            print(f"Error: File not found at {file_path}")
            return pd.DataFrame()
        except Exception as e:
            print(f"Error loading file: {e}")
            return pd.DataFrame()

    def fetch_market_data_from_yahoo(self, symbol: str, interval: str = '5m', start_date: str = '2020-01-01', end_date: str = '2021-01-01') -> pd.DataFrame:
        """
        @param symbol: The stock symbol (e.g., 'AAPL', 'MSFT').
        @param interval: The time interval for fetching data (default is '5m').
        @param start_date: The start date for the data in 'YYYY-MM-DD' format (default is '2020-01-01').
        @param end_date: The end date for the data in 'YYYY-MM-DD' format (default is '2021-01-01').
        @return: A pandas DataFrame containing the fetched market data.
        """
        try:
            data = yf.download(symbol, interval=interval, start=start_date, end=end_date)
            print(f"Data successfully fetched for {symbol} from {start_date} to {end_date} with {interval} interval.")
            return data
        except Exception as e:
            print(f"Error fetching data from Yahoo Finance: {e}")
            return pd.DataFrame()

    def calculate_indicators(self,df):
        """
        Generates technical indicators for a given DataFrame with Open, High, Low, Close, and Volume.
        Temporarily removes Ichimoku and VWAP calculations for debugging.
        """


        print("\nüîç Debugging Inside `calculate_indicators` Function...")

        # ‚úÖ Ensure correct sorting before calculation
        df = df.sort_index()

        # ‚úÖ Moving Averages (Fast, Slow, EMA)
        df["FastAvg"] = df["Close"].rolling(window=9).mean()
        df["SlowAvg"] = df["Close"].rolling(window=18).mean()
        df["FastEMA"] = df["Close"].ewm(span=9, adjust=False).mean()
        df["MedEMA"] = df["Close"].ewm(span=20, adjust=False).mean()
        df["SlowEMA"] = df["Close"].ewm(span=50, adjust=False).mean()

        # ‚úÖ Directional Movement Index & ADX
        df.ta.adx(append=True)

        # ‚úÖ Bollinger Bands (Upper, Lower, Mid)
        bbands = df.ta.bbands(length=20, std=2)
        df["UpperBand"] = bbands["BBU_20_2.0"]
        df["LowerBand"] = bbands["BBL_20_2.0"]
        df["MidLine"] = bbands["BBM_20_2.0"]

        # ‚úÖ Aroon Indicators
        df.ta.aroon(append=True)

        # ‚úÖ Relative Strength Index (RSI)
        df["RSI"] = df.ta.rsi(length=14)

        # ‚úÖ Volume-Based Indicators
        df["OBV"] = df.ta.obv()
        df["Up"] = np.where(df["Close"] > df["Open"], df["Volume"], 0)
        df["Down"] = np.where(df["Close"] < df["Open"], df["Volume"], 0)

        # ‚úÖ Momentum Indicators
        df["Momentum"] = df.ta.mom(length=10)
        df["ROC"] = df.ta.roc(length=10)
        df["CCI"] = df.ta.cci(length=20)

        # üöß Debug: Check the actual column names returned by `ta.stoch()`
        stoch = df.ta.stoch(length=14, k=3, d=3)
        print("\nüìå **Available Columns in Stochastic Output:**")
        print(stoch.columns)

        # ‚úÖ Ensure we correctly map the column names
        if "STOCHk_14_3_3" in stoch.columns and "STOCHd_14_3_3" in stoch.columns:
            df["SlowK"] = stoch["STOCHk_14_3_3"]
            df["SlowD"] = stoch["STOCHd_14_3_3"]
        else:
            print("\n‚ö†Ô∏è Warning: Stochastic column names do not match expected values. Skipping Stochastic calculation.")

        # üöß Commented out **VWAP Calculation** for debugging:
        """
        df["VWAP"] = df.ta.vwap(high=df["High"], low=df["Low"], close=df["Close"], volume=df["Volume"])
        """

        # üöß Commented out **Ichimoku Calculations** for debugging:
        """
        ichimoku = df.ta.ichimoku(tenkan=9, kijun=26, senkou=52)
        df["Tenkan"] = ichimoku["ITS_9"]
        df["Kijun"] = ichimoku["IKS_26"]
        df["Chikou"] = ichimoku["ICS_26"]
        df["SenkouSpan_A"] = ichimoku["ISA_9"]
        df["SenkouSpan_B"] = ichimoku["ISB_26"]
        """

        # ‚úÖ Custom Momentum Decrease (1-4 Bars Ago)
        df["MomDecr1"] = (df["Momentum"].rolling(window=2).mean().diff() < 0).astype(int)
        df["MomDecr2"] = (df["Momentum"].rolling(window=3).mean().diff() < 0).astype(int)
        df["MomDecr3"] = (df["Momentum"].rolling(window=4).mean().diff() < 0).astype(int)
        df["MomDecr4"] = (df["Momentum"].rolling(window=5).mean().diff() < 0).astype(int)

        return df



    def align_and_validate_simulation(self, training_df: pd.DataFrame, simulation_df: pd.DataFrame, interval_minutes=5):
        """
        Ensures simulation data starts immediately after training data ends.
        Also ensures no gaps within the expected time interval.

        Raises ValueError if gaps are found.
        Adjusts simulation_df in-place if overlap exists.

        @param training_df: Loaded training data.
        @param simulation_df: Loaded simulation data.
        @param interval_minutes: Expected bar interval (default 5 minutes).
        """
        # Get last bar from training
        last_training_date = training_df.iloc[-1]["Date"]
        last_training_time = training_df.iloc[-1]["Time"]

        # Convert to timestamp for easy math
        last_training_ts = pd.to_datetime(f"{last_training_date} {last_training_time}")

        # Get first bar from simulation
        first_sim_date = simulation_df.iloc[0]["Date"]
        first_sim_time = simulation_df.iloc[0]["Time"]
        first_sim_ts = pd.to_datetime(f"{first_sim_date} {first_sim_time}")

        # ‚úÖ Check for overlap (training ends after simulation starts)
        if last_training_ts >= first_sim_ts:
            # Slice simulation to remove overlap (keep only bars after training ends)
            simulation_df = simulation_df[simulation_df.apply(
                lambda row: pd.to_datetime(f"{row['Date']} {row['Time']}") > last_training_ts,
                axis=1
            )]
            print("üîó Simulation trimmed to avoid overlap with training data.")

        # ‚úÖ Check for gap (missing bars between training and simulation)
        expected_start = last_training_ts + pd.Timedelta(minutes=interval_minutes)
        if first_sim_ts > expected_start:
            raise ValueError(f"‚ö†Ô∏è Gap detected between training and simulation data! "
                             f"Expected: {expected_start}, Found: {first_sim_ts}")

        return simulation_df  # Return the aligned and validated simulation data

"""# Example Cell"""

# # Sample cell to use `fetch_market_data_from_yahoo()` method

# # Create an instance of DataLoader
# data_loader = DataLoader()

# # Fetch market data from Yahoo Finance
# symbol = 'AAPL'  # Stock symbol (e.g., 'AAPL', 'MSFT')
# interval = '5m'   # 5-minute interval
# start_date = '2025-01-10'
# end_date = '2025-01-15'

# market_data = data_loader.fetch_market_data_from_yahoo(symbol, interval, start_date,end_date)

# # Display the first few rows of the fetched data
# print(market_data.head())

